{
	// Place your competitive-programming-cpp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"AtCoder": {
		"scope": "cpp",
		"prefix": "atcoder",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#include <atcoder/all>",
			"using namespace atcoder;",
			"",
			"using ll = long long;",
			"using P = pair<ll, ll>;",
			"",
			"#define rep(i, n) for (int i = 0; i < (int)(n); ++i)",
			"",
			"int main() {",
			"    $0",
			"",
			"    return 0;",
			"}"
		]
	},
	"AOJ": {
		"scope": "cpp",
		"prefix": "aoj",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"using ll = long long;",
			"using P = pair<ll, ll>;",
			"",
			"#define rep(i, n) for (int i = 0; i < (int)(n); ++i)",
			"",
			"int main() {",
			"    $0",
			"",
			"    return 0;",
			"}"
		]
	},
	"INF": {
		"scope": "cpp",
		"prefix": "INF",
		"body": [
			"const ll INF = 1'000'000'000'000'000'000;",
		]
	},
	"yes_or_no": {
		"scope": "cpp",
		"prefix": "yes_or_no",
		"body": [
			"if ($0) {",
			"    cout << \"Yes\" << endl;",
			"} else {",
			"    cout << \"No\" << endl;",
			"}",
		]
	},
	"chmin": {
		"scope": "cpp",
		"prefix": "chmin",
		"body": [
			"template<class T> inline bool chmin(T& a, T b) {",
			"    if (a > b) {",
			"        a = b;",
			"        return true;",
			"    }",
			"    return false;",
			"}",
		]
	},
	"chmax": {
		"scope": "cpp",
		"prefix": "chmax",
		"body": [
			"template<class T> inline bool chmax(T& a, T b) {",
			"    if (a < b) {",
			"        a = b;",
			"        return true;",
			"    }",
			"    return false;",
			"}",
		]
	},
	"warshall_floyd": {
		"scope": "cpp",
		"prefix": "warshall_floyd",
		"body": [
			"#include <bits/stdc++.h>",
			"struct warshall_floyd {",
			"public:",
			"    warshall_floyd(int n) : _n(n) {",
			"        d = std::vector<std::vector<long long>>(_n, std::vector<long long>(_n, INF));",
			"        for (int i = 0; i < _n; i++) {",
			"            d[i][i] = 0;",
			"        }",
			"    }",
			"",
			"    void add_edge(int from, int to, long long cost) {",
			"        d[from][to] = std::min(d[from][to], cost);",
			"    }",
			"",
			"    void solve() {",
			"        for (int k = 0; k < _n; k++) {",
			"            for (int i = 0; i < _n; i++) {",
			"                for (int j = 0; j < _n; j++) {",
			"                    if (d[i][k] < INF && d[k][j] < INF) {",
			"                        d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    bool has_negative_cycle() {",
			"        for (int i = 0; i < _n; i++) {",
			"            if (d[i][i] < 0) {",
			"                return true;",
			"            }",
			"        }",
			"        return false;",
			"    }",
			"",
			"    bool reachable(int from, int to) {",
			"        if (d[from][to] >= INF) {",
			"            return false;",
			"        } else {",
			"            return true;",
			"        }",
			"    }",
			"",
			"    long long shortest_path(int from, int to) {",
			"        return d[from][to];",
			"    }",
			"",
			"private:",
			"    const long long INF = 1'000'000'000'000'000'000;",
			"    int _n;",
			"    std::vector<std::vector<long long>> d;",
			"};",
		]
	},
	"union_find": {
		"scope": "cpp",
		"prefix": "union_find",
		"body": [
			"#include <bits/stdc++.h>",
			"struct union_find {",
			"public:",
			"    union_find(int n) {",
			"        par = std::vector<int>(n);",
			"        for (int i = 0; i < n; i++) {",
			"            par[i] = i;",
			"        }",
			"        rank = std::vector<int>(n, 0);",
			"    }",
			"",
			"    int find(int x) {",
			"        if (par[x] == x) {",
			"            return x;",
			"        } else {",
			"            return par[x] = find(par[x]);",
			"        }",
			"    }",
			"",
			"    void unite(int x, int y) {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y) {",
			"            return;",
			"        }",
			"",
			"        if (rank[x] < rank[y]) {",
			"            par[x] = y;",
			"        } else {",
			"            par[y] = x;",
			"            if (rank[x] == rank[y]) {",
			"                rank[x]++;",
			"            }",
			"        }",
			"    }",
			"",
			"    bool same(int x, int y) {",
			"        return find(x) == find(y);",
			"    }",
			"private:",
			"    std::vector<int> par;",
			"    std::vector<int> rank;",
			"};",
		],
	}
}